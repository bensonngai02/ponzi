April 24, 2022
LISP - expression oriented language (no difference between expressions + statements)
SECD Machine
-   Stack, Environment, Control, Dump
-   Specifically designed to evaluate lambda calculus expressions (Lisp)

    S Register (Stack)
        - Holds intermediate results when computer values of expressions
        - Stack is a list → Point at list head 
        - Stack space doesn’t have to be continuous
        - Can use discontinuous memory cells
        - Garbage collection
    E Register (Environment)
        - Current variable environment
        - Holds values bound to variables during evaluation
        - List of lists
            - ((3 17) (A B) (C D))
        - Variables at head of list
        - Variables that are free in the current function are also in list
        - Other stuff too
    C Register (Control)
        - Program counter
        - Holds machine language program being executed
        - Pointer to head of code (instruction list)
        - When instruction is executed → move on to next instruction in list
    D Register (Dump)
        - Return stack
        - Saves values of other registers upon calling a new function

- Each register contains a POINTER to a data structure reprsenting an S-Expression
- Each instruction can be denoted by a 'machine transition' format
    - s e c d -> s' e' c' d'
        - where s, e, c, d represent the AFTER state
        - s', e', c', d' represent the BEFORE state

Compiler
    - If c is the code generated from a well-formed expression
        - s e c d -> (x.s) e NIL d
    - Namelist - list of lists (instructions)
        - ie. ((A) (X Y) (APPEND REV DUP))
        - to compute an index pair with 'location'
        - position (x, a) = if eq(x, car(a)) then 0
                            else 1 + position(x, cdr(a))
                            where x = variable we're looking for
                                  n = name list
                                  a = list of atoms (sublist of n)
        - location (x, n) = if member(x, car(n)) then cons(0, position(x, car(n)))
                            else {cons(car(z) + 1), cdr(z)}
                            where z = location(x, cdr(n))
    - Putting Expressions + Namelists together
            - e*n where e = expression, n = Namelist
            - x*n = (LD i) where i = location(x,n)
            - (QUOTE s) *n = (LDC s)


Example: (1 2 3)			// list holding numbers 1, 2, 3

Links:
https://vaxbusters.org/workshop/secd.xml 
http://www.elizas.website/seax/implementation/secd.html
https://github.com/zachallaun/secd
https://jaredkrinke.github.io/learn-scheme/1-1-7-examplesquarer.html


LISP Syntax
Integer Operations
( + 21 35 12 7)
(+ (* 3 5) (- 10 6))
Prefix notation + integer operations can take arbitrary # of arguments
Define
Establishes variable bindings
Basically string substitution
(define size 2) → everywhere that uses size is now 2
(define circumference (* 4 pi radius size))
(define (square x) (*x x x))
Function - to square something, multiply it by itself
(define (<name> <formal parameters>) <body>)
Creating definition of function ‘f’ with parameter ‘a’ and body sum of squares
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

(f 5)
Retrieve body of f, then replace formal parameter ‘a’ with argument 5
Defining a Procedure
(define square
     (lambda (n)
          (* n n)))
Lambda - creates procedures
Conditions

Cond
    (define (abs x)
    (cond ((> x 0) x)
            ((= x 0) 0)
            ((< x 0) (- x))))

General Form: 
    (cond (<p1> <e1>)
        (<p2> <e2>)
        (<pn> <en>))

If
    (if <predicate> <consequent> <alternative>)

Else
    (define (abs x)
    (cond ((< x 0) (- x))
            (else x)))

And
    (and (> x 5) (< x 10))

Or 
    (define (>= x y)
    (or (> x y) (= x y)))
  
Not
    (define (>= x y)
    (not (< x y)))

True
    #t

False
    #f

Predicates - names end with a question mark
    Eq? 
    Zero?
    string=?

April 27, 2022

Stacks 
Malloc ~ 8192 bytes
Stack pointer. To push, increment the stack pointer. To 

Create stack pointer stack that keeps track of pointers to stack bases.
That way, we can make stack dynamic - grow.
Or
We can realloc with C.

April 28, 2022
- write code for stack
- define our types
    - atom (struct union)
        - integers
        - booleans
        - strings ("nil", "omega")
    - s-expression (class)
        - make it a class
        - make methods around class
            - location, index, position, etc.
    - Machine class
        - Pointers: S, E, C, D
        - malloc every time you need to add to linked list
