#include "compiler.h"

using namespace std;

set<string> variables;

// global flag controls issue of returning 0 to else-if statement in function e1 (line 144)
bool literalFlag = true;

[[noreturn]]
void fail()
{
    printf("current letter: %c\n", this->current[0]);
    printf("failed at offset %ld\n", (this->current - this->program));
    printf("%s\n", this->current); // print current char in string
    exit(1);
}

void endOrFail()
{
    while (isspace(*(this->current)))
    {
        this->current += 1;
    }
    if (*(this->current) != 0)
        fail();
}

void skip()
{
    while (isspace(*(compiler->current)))
    {
        this->current += 1;
    }
}

/* peeks at the next character */
bool peek(const char * str) {
    skip();
 
    size_t i = 0; 
    while (true)
    {
        char const expected = str[i];
        char const found = (this->current)[i];
        if (expected == 0)
        {
            /* survived to the end of the expected string */
            return true;
        }
        if (expected != found)
        {
            return false;
        }
        // assertion: found != 0
        // moves to the next character to consume
        i += 1;
    }
}

/* consumes the next available token in the given string input */
bool consume(const char *str)
{
    skip();

    size_t i = 0;
    while (true)
    {
        char const expected = str[i];
        char const found = (this->current)[i];
        if (expected == 0)
        {
            /* survived to the end of the expected string */
            (this->current) += i;
            return true;
        }
        if (expected != found)
        {
            return false;
        }
        // assertion: found != 0
        // moves to the next character to consume
        i += 1;
    }
}

void consumeOrFail(const char *str)
{
    if (!consume(str, compiler))
        fail(compiler);
}

/* returns string identifier that was consumed */
std::optional<string> consumeIdentifier()
{
    skip();
    std::string newString = "";

    if (isalpha(*(this->current)))
    {
        do
        {
            newString += *(this->current);
            (this->current) += 1;
        } while (isalnum(*(this->current)));

        return newString;
    }
    else
    {
        return {};
    }
}

/* returns integer token found in expression from input */
int64_t consumeLiteral()
{
    skip();
    literalFlag = true;

    if (isdigit(*(this->current)))
    {
        uint64_t v = 0;
        do
        {
            v = 10 * v + (*(this->current) - '0');
            (this->current) += 1;
        } while (isdigit(*(this->current)));
        return v;
    }
    else
    {
        literalFlag = false;
        return false;
    }
}

void eatFunction(bool effects) {
    // ignores the code in the function block
    if (consume("{")) {
        while (!consume("}")) {
            statement(effects);
        }
    }
}

int64_t e1(bool effects)
{
    uint64_t literal;
    uint64_t v = 0;
    int localFunctionCount;
    
    if (consume("fun")) {
        statement(effects);
    }
    
    else if (auto identifier = consumeIdentifier())
    {
        variables.insert({identifier.value()});
        
        if (compiler->current[0] == '('){
            consume("(");
            expression(effects);
            consume(")");
        }

        else {
            return v;
        }
        
    }
    else if ((literal = consumeLiteral()) || literalFlag)
    {
        return literal;
    }
    else if (consume("("))
    {
        expression(effects);
        while (consume(")"));
        return 0;
    }
    else
    {
        fail();
    }
    return false;
}

// ++ -- unary+ unary- ... (Right)
int64_t e2(bool effects)
{
    return (e1(effects));
}

// * / % (Left)
int64_t e3(bool effects)
{
    int64_t v = e2(effects);

    while (true)
    {
        if (consume("*"))
        {
            e2(effects);
        }
        else if (consume("/"))
        {
            e2(effects);
        }
        else
        {
            return v;
        }
    }
}

// (Left) + -
int64_t e4(bool effects)
{
    uint64_t v = e3(effects);

    while (true)
    {
        if (consume("+"))
        {
            e3(effects);
        }
        else if (consume("-"))
        {
            e3(effects);
        }
        else
        {
            return v;
        }
    }
}

// < <= > >=
int64_t e5(bool effects)
{
    uint64_t v = e4(effects);

    while (true)
    {
        if (consume("<="))
        {
            e4(effects);
        } 
        else if (consume(">="))
        {
            e4(effects);
        } 
        else if (consume("<"))
        {
            e4(effects);
        } 
        else if (consume(">"))
        {
            e4(effects);
        } 
        else {
            return v;
        }
    }
}

// == !=
int64_t e6(bool effects)
{
    uint64_t v = e5(effects);

    while (true)
    {
        if (consume("==")) {
            e5(effects);
        }
        else if (consume("!=")) {
            e5(effects);
        }
        else {
            return v;
        }
    }
}

// (left) &
int64_t e7(bool effects)
{
    uint64_t v = e6(effects);

    while (true) {
        if (!peek("&&") && consume("&")) {
            e6(effects);
            
        } else {
            return v;
        }
    }
}

// &&
int64_t e8(bool effects)
{
    uint64_t v = e7(effects);

    while (true) {
        if (consume("&&")) {

            e7(effects);

            return 0;
            
        }
        else {
            return v;
        }
    }
}

// ||
int64_t e9(bool effects)
{
    uint64_t v = e8(effects);

    while (true) {
        
        if (consume("||")) {
            
            e8(effects);

            return 0;
        }
        else {
            return v;
        }
    }
}

int64_t expression(bool effects)
{
    return e9(effects);
}

bool statement(bool effects)
{

    if (consume("if")) {
        
        expression(effects);
        
        statement(effects);
       
        if (consume("else")) {
            statement(effects);
        }

        return true;
    }
 
    /* Reads the entire block of code */
    else if (consume("{")) {
        while (!consume("}")) {
            statement(effects);
        }
    }

    else if (consume("return")) {
        
        expression(effects);

        return true;
    }
    else if (consume("print"))
    {
        // print ...
        expression(effects);

        return true;
    }
    else if (auto identifier = consumeIdentifier())
    {
        variables.insert({identifier.value()});
        // x = ...
        if (consume("="))
        {
            expression(effects);
        

            return true;
        }
        else
            fail();
    }
    return false;
}


void statements(bool effects)
{
    while (statement(effects));
}

void run()
{
    statements(true);
    endOrFail();
}


int main(int argc, char** argv) {
    if (argc != 2) {
        printf("usage: %s <fun file name>\n",argv[0]);
        exit(-1);
    }

    // open the file
    int fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        exit(1);
    }

    // determine its size (std::filesystem::get_size?)
    struct stat file_stats;
    int rc = fstat(fd, &file_stats);
    if (rc != 0)
    {
        perror("fstat");
        exit(1);
    }

    // map the file in my address space - mmap returns pointer to a block of memory
    char *prog = (char *)mmap(
        0,
        file_stats.st_size,
        PROT_READ,
        MAP_PRIVATE,
        fd,
        0);

    if (prog == MAP_FAILED)
    {
        perror("mmap");
        exit(1);
    }

    run();
   
    return 0;
}









 char * program;
    char * current;

    public:
        void fail();
        void endOrFail();
        void skip();
        bool peek(const char * str);
        bool consume(const char * str);
        void consumeOrFail(const char * str);
        std::string consumeIdentifier();
        int64_t consumeLiteral();
        void eatFunction(bool effects);
        int64_t e1(bool effects);
        int64_t e2(bool effects);
        int64_t e3(bool effects);
        int64_t e4(bool effects);
        int64_t e5(bool effects);
        int64_t e6(bool effects);
        int64_t e7(bool effects);
        int64_t e8(bool effects);
        int64_t e9(bool effects);
        int64_t e10(bool effects);
        int64_t e11(bool effects);
        int64_t e12(bool effects);
        int64_t expression(bool effects);
        bool statement(bool effects);
        void statments(bool effects);
        void run();